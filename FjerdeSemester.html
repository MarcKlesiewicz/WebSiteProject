<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marc klesiewicz - 4. semester</title>

    <!-- css stylesheets-->
    <link rel="stylesheet" href="sheet-reset.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="ProjectsStyles.css">
    <link rel="stylesheet" href="FjerdeSemStyles.css">

    <!-- Google fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">

</head>

<body>

    <!--HEADER-->
    <div class="header-container">
        <header>
            <a href="Index.html"><img class="logo" src="images/logo.png" alt=""></a>


            <a href="javascript:history.back()" style="margin-right: 100px;">
                <h1 class="exitcross">X</h1>
            </a>

        </header>

    </div>

    <div class="projectintro">

        <h1>4. semester forløb på Datamatikeruddannelsen</h1>
        <hr>
        <h2>Hej. Jeg vil under mit semester dokumentere min proces i et blog-format, løbende med ny viden,
            eksperimenter, færdigheder og konklusioner indenfor mine to valgte emner. <br> <span
                style="color: #FF6C8A;"> Frontend development <br> & <br> Database med fokus på Blockchain Teknologi
            </span> <br>
        </h2>


        <a href="#new" class="projectnavbuttons">Seneste oplæg</a>
        <a href="#" class="projectnavbuttons">Litteraturliste</a>


    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Semester introduktion</h2>
        <div class="projectLabel">
            <b>Projekt</b>
        </div>
        <h5 class="blogcontext">02-02-2022</h5>
        <p class="blogcontext">Som et del af mit uddannelsesforløb skal jeg under mit 4. semester på datamatikerstudiet
            selv være ansvarlig for min læring i form af et selvstudie. Dette indebære valg af to forskellige emner som
            jeg ikke har tidligere erfaringer med og indgåelse af et samarbejde med en virksomhed som står en
            problemstilling. <br> <br>

            Mit første emne er <b>Frontend Programmering</b>, helt specifik Crossplatform App-Development med
            <b>Flutter</b> og <b>Dart</b> som programmeringssprog. Jeg har tidligere erfaringer med android development
            på et lav praksis niveau og har siden haft en interesse i at gøre en karriere ud af det. Jeg vil løbende
            demontere mine erfaringer med app udvikling på denne blog i form af updates på semester-projektet og
            eksperimentere med sideløbende projekter. <br><br>

            Som mit andet emne har jeg valgt <b>Database</b> med et særligt fokus på <b>Blockchain Teknologi</b>. Så
            først og fremmest vil jeg fordybe mig i database koncepter og demonstrere brugen af Google Firebase og
            Hive. <br>
            Men udover det vil jeg dykke ned i det alternative potentiale der findes i Blockchain, ved at undersøge
            logikken bag, hvordan eksisterende virksomheder praktisere brugen af det, hvorfor det anses som
            revolutionerende teknologi og hvordan det evt. kan inkorporeres i en anderledes use case. <br><br>

            Nedenfor er der linket til et roadmap for hvert emne, men potentielle emner jeg vil dække i fremtidige
            blogindlæg. <br>

        <ul class="a">
            <li><a href="https://github.com/olexale/flutter_roadmap">Flutter Developer Roadmap</a></li>
            <li><a href="https://github.com/Envoy-VC/blockchain-app-developer-roadmap">Blockchain App Developer
                    Roadmap</a></li>
        </ul>
        </p>

        <p class="blogcontext">
            Før opstart af dette semester indgik mit team og jeg i et samarbejde med virksomheden <a
                href="https://littlegiants.dk/">Little Giants</a>. <br>
            Little Giants er et dansk app bureau, baseret i Odense, der specialisere sig indenfor rådgivning, udvikling
            og vedligeholdelse af crossplatform applikationer. De har givet os muligheden for at arbejde og udvikle
            vores evner på et af deres projekter ved navn <b>RENTO</b>, som vil blive dækket i et andet opslag.
        </p>


    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Mine individuelle læringsmål</h2>
        <div class="projectLabel">
            <b>Projekt</b>
        </div>
        <h5 class="blogcontext">04-02-2022</h5>
        <p class="blogcontext">I løbet af dette semester vil jeg selv skulle opstille mine læringsmåls for valgte emner,
            som vil forholdsvis være inddelt i viden, færdigheder og kompetencer. I slutningen af semesteret vil de
            argere som udgangspunkt for min forståelse af emnerne til eksamen. <br>
            Jeg vil løbende opdatere mine læringsmål <a
                href="https://docs.google.com/document/d/1Wdp6iREVuLXjsZsVi9wzvpb0XN36kjQkzgipfkCxYrI/edit?usp=sharing">her.</a><br><br>

            <b style="color: #FF6C8A;">Frontend programmering</b><br>
            <b>Viden</b><br>
            Den studerende har:
        <ul>
            <li>Udviklingsbaseret viden om brug af Flutter basic widget og 3rd-party widget.</li>
            <li>Forståelse for teoretisk og praksis vedrørende komponentbaseret programmering.</li>
            <li>Fundamental viden om Dart programmeringssproget og tilsvarende kodestil.</li>
            <li>Have kendskab til frontend standarder og hvordan de kan differentiere sig fra operativsystemer.</li>
            <li>Indsigt i en crossplatform udviklingsproces og Flutter arkitektur.</li>

        </ul>
        </p>

        <p class="blogcontext">

            <b>Færdigheder</b><br>
            Den studerende kan:
        <ul>
            <li>Anvende centrale teknikker og værktøjer til designe, konstruering, testing og udgivelse af crossplatform
                applikationer med Flutter/Dart</li>
            <li>Redegøre for typisk anvendte design mønstre indenfor app udvikling og vurdere hvornår de bør anvendes.
            </li>
            <li>Anvende centrale app design principper.</li>

        </ul>

        </p>

        <p class="blogcontext">

            <b>Kompetencer</b><br>
            Den studerende kan:
        <ul>
            <li>Bidrage til et programmeringsprojekt i et eksisterende udviklingsmiljø</li>
            <li>Professionelt varetage ansvarsområder i et projekt</li>
            <li>Håndtere autentisk kundekontakt og formidling af udviklingsproces</li>
            <li>Perspektivere og relatere emnets omfang til andre it-faglige problemstillinger</li>
        </ul>

        </p>

        <p class="blogcontext">
            <b style="color: #FF6C8A;">Database</b><br>

            <b>Viden</b><br>
            Den studerende kan:
        <ul>
            <li>Udviklingsbaseret viden om database koncepter og paradigmer indenfor app udvikling.</li>
            <li>Kendskab til teoretisk og praktisk brug af decentraliseret netværker og use cases de anvendes i.</li>
            <li>Perspektiverende indsigt i logikken bag Blockchain Teknologi og konsensusmekanismer.</li>
            <li>Fundamental viden til Solidity programmeringssprog, Remix IDE og Truffle Framework</li>
        </ul>

        </p>

        <p class="blogcontext">

            <b>Kompetencer</b><br>
            Den studerende kan:
        <ul>
            <li>Demonstrerer forskellige former for simple persistens.</li>
            <li>Praktisere centrale principper og best practice til implementeringer af persistens i mobile apps</li>
            <li>Designe og udvikle applikationer som lagre gennem Google Firebase</li>
            <li>Anvende centrale metode og værktøjer til konstruering, testing og udgivelse af smart contracts.</li>
        </ul>

        </p>

        <p class="blogcontext">

            <b>Kompetencer</b><br>
            Den studerende kan:
        <ul>
            <li>Bidrage til et programmeringsprojekt i et eksisterende udviklingsmiljø</li>
            <li>Professionelt varetage ansvarsområder i et projekt</li>
            <li>Håndtere autentisk kundekontakt og formidling af udviklingsproces</li>
            <li>Perspektivere og relatere emnets omfang til andre it-faglige problemstillinger</li>
        </ul>

        </p>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Produktbeskrivelse</h2>
        <div class="productLabel">
            <b>Produkt</b>
        </div>
        <h5 class="blogcontext">07-02-2022</h5>
        <p class="blogcontext"> <a href="https://rento.com/">Rento</a> er en platform, hvor brugerne kan leje et
            værktøj, redskab eller noget helt tredje af andre brugere til overkommelige priser, i kontrast til selv at
            købe dem. Som bruger vil du derfor også selv kunne oprette et “produkt” med tilsvarende billeder,
            produktinformation og ledige lejeperioder - og derved generer passive indkomst gennem Rentos service (som en
            AirBnb for redskaber) <br>
            Brugerne vil selv være ansvarlig for udlejningen og tilbagelevering af et produkt, men er sikret gennem
            Rentos forsikringsanordning, der vil gøre brugerne trygge i at udleje deres ejendele. <br>
            Målgruppen er hovedsageligt privat privatpersoner, men der vil også være muligheder for virksomheder at
            registrere sig som bruger og på den måde gøre det endnu nemmere for dem at nå ud til potentialle kunder.
            <br><br>

            Rentos MVP er en mobil applikation til IOS og Android enheder. Den vil blive udvikle som en crossplatform
            app, hvilket betyder at der kun vil være en codebase for hele projektet som fungere på alle
            operativsystemer. Backend delen appen vil udviklet med TypeScript. Frontend vil blive udviklet med Google UI
            toolkit Flutter, som bliver skrevet i programmeringssproget Dart.

        <div style="display: flex; text-align: center; width: 100%; justify-content: space-evenly; height: 400px; ">
            <img src="images/rento_splash.png" alt="">
            <img src="images/rento_dashboard.png" alt="">
            <img src="images/rento_product.png" alt="">
            <img src="images/rento_profile.png" alt="">


        </div>


        </p>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Projektopstart</h2>
        <div style="display: flex;">
            <div class="projectLabel" style="margin-right: 5px;">
                <b>Projekt</b>
            </div>
            <div class="productLabel">
                <b>Produkt</b>
            </div>
        </div>
        <h5 class="blogcontext">08-02-2022</h5>
        <p class="blogcontext"> Første reelle dag for opstart af projektet, foregik allerede tilbage i november/december
            hvor mit team og jeg besøgte Little Giants for at blive introduceret til projektets omfang. Her gennemgik vi
            appens daværende design, funktionelle krav, domæne og estimerede tilsvarende issues som blev opstillet
            baseret på kravene. <br><br>
            Nedenstående billede illustrere appens nuværende domæne model
        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/rento_domain.png" alt="" style="width: 70%;">
        </div>

        <p class="blogcontext">Med en god basal indsigt i projektets omfang, kunne jeg de første dage fokusere på at
            blive sat ind i de værktøjer og aktiviteter Little Giants bruger som jeg ikke kendte i forvejen. <br> <br>

        <ul>
            <li>Til projektstyring bruger vi ClickUp. Indtil videre bruger vi det til håndtere og administrer de enkelte
                systemkrav, formuleret som userstories, og deres underlæggende issues. Et issues består af en type
                (backend, app eller web), en estimeret tid, en registreret tid og en ansvarlig.</li>
            <li>Github vil bruges til versionering, hvor der vil være separate respositories for backend og frontend.
                Under projektet vil vi benytte feature branching, pull request og review før merge.</li>
            <li>Projektorienteret kommunikation bruges Discord.</li>
            <li>Design og prototype af applikationen vil/er udviklet ved hjælp af Figma.</li>
            <li>Selve udviklingen vil foregå i Visual Studio Code IDE med følgende extenstions:
                <ul>
                    <li>Dart, Flutter, Docker, Error Lens, Flutter Riverpod Snippets, Freezed, Git Graph, i18n Ally og
                        PlantUML</li>
                </ul>
            </li>
            <li>Til dokumentering af systemet og udformning af UML bruges PlantUML, som nemt kan generere
                systemdokumentation baseret på simple textual beskrivelse.</li>
            <li>Projektaktiviteter vil der hver morgen blive lavet et uformelt standup meeting, hvor hvert teammedlem
                fortæller hvad de skal arbejde med den dag og evt. udfordringer der kan eller er opstået. </li>
        </ul>

        </p>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Flutter/Dart introduktion</h2>

        <div class="frontendLabel" style="margin-right: 5px;">
            <b>Frontend</b>
        </div>

        <h5 class="blogcontext">11-02-2022</h5>
        <p class="blogcontext">
            Her til at starte med har jeg valgt at fokusere på mit emne Frontend Programmering, fordi det kan nemmest
            relatere til udviklingen af selve produktet. Jeg (+ et teammedlem) vil under forløbet være udelukkende
            ansvarlige for udvikling af produktets frontend, som vil blive lavet med Flutter og Dart. <br><br>

            <i>Dette er min nuværende forståelse af Flutter og Dart (11/2/2022).</i><br>

        <div style="width: 100%; display: flex;">

            <div style="width: 100%;">

                <p class="blogcontext">
                    Flutter er Googles take på et UI software development kit (SDK), som der kan bruges til at udvikle
                    cross platform applikationer. Når man snakker om noget er cross platform vil det sige at der kun
                    eksistere en codebase, som fungere på flere operativ systemer. <br>
                    Før i tiden blev der kun udviklet native applikationer til Android og IOS. De skulle hver især
                    udvikles i forskellige IDE'er, frameworks og kodes med forskellige programmeringssprog. Dette er
                    enorm tidskrævende og dyrt, fordi du i bund og grund skal lave den samme app to gange hvis din app
                    skal være på begge platforme. <br><br>

                    Med Flutter behøves vi kun at skrive koden en gang - dog er Flutter ikke koden, men frameworket som
                    forsyner os med de pre-defineret widget, libraries, packages og functioner som gør det muligt at
                    udvikle en universal codebase. <br><br>

                    Måden vi så kan drage nytte af Flutter er med Dart(naturligvis udviklet af Google), som er et
                    programmeringssproget vi blandt andet bruger til at definere udseendet af en Flutter app og hvordan
                    brugergrænsefladen skal interagere med backend koden - også kaldt for et klient-optimeret sprog.

                </p>

            </div>

            <div style="width: 70%; text-align: right;">

                <img src="images/flutterio-ar21.svg" alt="" style="display: block; height: 200px;">
                <img src="images/dartlang-ar21.svg" alt="" style="display: block; height: 200px;">

            </div>

        </div>

        </p>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Database introduktion</h2>

        <div class="databaseLabel" style="margin-right: 5px;">
            <b>Database</b>
        </div>

        <h5 class="blogcontext">14-02-2022</h5>
        <p class="blogcontext">
            <b>Blockchain</b> var et buzzword som jeg stødte på mange gange i løbet af sidste år - ofte i kontekst til
            kryptovaluta og NFT'er. Efter at have researchet på emnet kunne jeg fornemme at der var mange som så denne
            teknologi som revolutionerende og havde et kæmpe potentiale til at ændre måden vi interagere med hinanden på
            nettet.<br><br>

            <i>Dette er min nuværende forståelse af Blockchain teknologi (14/02/2022).</i><br><br>

            Blockchain er en teknologi som havde sin debut tilbage i 2009 da Satoshi Nakamoto (som man ikke ved om er en
            person eller et team) lancerede verdens første kryptovaluta, Bitcoin. <br>
            Bitcoins blockchains formål er at bogføre transaktioner af bitcoin mellem brugere og kan derfor ses som et
            kæmpe regneark. Men det som kendetegne en blockchain er at den er <b>decentraliseret</b>. Det vil sige at
            hvem som helst vil kunne tilgå det her "regneark" og validere om en transaktion har fundet sted. I kontrast
            til en <b>centraliseret</b> database som typisk er eget af en virksomhed eller regering, drives en
            decentraliseret database af <b>peer-to-peer</b> netværk af enheder fordelt over hele verden. <br>
            Det helt unikke ved en blockchain at alle transaktioner vil være lagret i "blocks". En block kan ca.
            opbevarer 3500 transaktioner - og ved max kapacitet generere, ved brug af en hashing algoritme, en unik
            indentifier som den næste block i kæden vil kende til. På den måde anses en blockchain som uforanderlig,
            fordi at den mindste ændring af en transaktion vil medfører en helt anden indentifier. <br>
            For ikke at manuelt skulle sidde og validere en hel blockchain, har man udviklet <b>konsensusmekanismer</b>.
            Der findes forskellige former for konsensus, men fællesnævneren for dem er at det et stykke hardware som
            udfører nogle matematiske kalkulationer der hurtigt kan validere en blocks "ægthed". <br> <br>

            <b>Datebase + konsensus = blockchain</b> <br><br>

        <div style="width: 100%; display: flex;">

            <div style="width: 100%;">

                <p class="blogcontext">
                    Men før jeg begynder at tage fat i blockchain, vil jeg gerne eksperimentere med nogle databaser som
                    typisk bliver brugt til app udvikling. Så det første jeg har gjorde var at undersøge hvilket
                    muligheder der var. <br> <br>
                    Konklusion: der er utrolig mange og på de fleste forums skriver folk at valget af din database
                    afhænger utrolig meget af opgaven/appen hvor den skal bruges. <br><br>

                    Det giver naturligvis god mening. Så derfor ville jeg gerne finde en database som var alsidig ift.
                    usecases den bruges i og så skulle den være veldokumenteret. <br>
                    En som jeg havde hørt om før og som også blev nævnt flere gange i Flutter forums var <b>Google
                        Firebase</b>. Den bliver beskrevet som en meget skalerbart løsning til både persistens,
                    authentication og cloud messaging (alle sammen funktionaliteter som skal være i projekt-produktet).
                    <br>
                    Derudover ville det give god mening at der synergi mellem Firebase og Flutter, eftersom det er
                    udviklet af den samme virksomhed. <br> <br>

                    Ved brug af Firebase er mit data lagret på Googles server - så jeg kunne også godt tænke mig at
                    undersøge et alternativ til det. <br> Til det har jeg fundet en anden persitens løsning som hedder
                    <b>Hive</b>. Den bliver beskrevet som en avanceret lokal NoSQL database som bliver implementeret
                    direkte i frontenden og skulle have enorm hurtig eksekveringstid.


                </p>

            </div>

            <div style="width: 70%; text-align: center;">

                <img src="images/Firebase_logotext.png" alt=""
                    style="display: block; width: 500px; margin-bottom: 50px; margin-top: 100px;">
                <img src="images/hive_logotext.png" alt="" style="display: block; width: 400px;">

            </div>

        </div>

        </p>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Alt er et widget</h2>
        <div class="frontendLabel" style="margin-right: 5px;">
            <b>Frontend</b>
        </div>

        <h5 class="blogcontext">17-02-2022</h5>
        <p class="blogcontext"> De sidste to uger har jeg brugt på at blive bekendt med nogle af de fundamentale
            principper indenfor Flutter og Dart. <br> Jeg har startet med at læse de første to sektioner af <b>Flutter
                Apprentice</b> , som er en bog jeg har fundet gennem anbefalinger på diverse forums. Indtil videre har
            jeg fundet
            den utrolig hjælpsom til setup i VS Code - samt lære grundkoncepterne til selv at lave en applikation med
            Flutter og Dart. <br><br>

            Den først konklusion jeg har kunne drage, er at i Flutter er ALT et widget... <br>
            Et widget er ifølge Flutters egen dokumentation, et element i en Flutter app som enten beskriver hvordan
            brugergrænseflade ser ud eller reagere ved interaktion. Der findes 14 widget hovedkategorier - baseret på
            den funktionalitet de hver især forsyner appen med. <br>
            Jeg vil løbende dokumentere min viden opmkring disse kategorier og hvordan jeg bruger dem i mine projekter.
            <br><br>

            For at demonstrere nogle af de mere basale kategorier jeg er blevet bekendte med, har jeg lavet denne simpel
            applikation som kan kalkulere mængden af ingredienser til en ret. <br> <br> <a
                href="https://github.com/MarcKlesiewicz/recipes_flutter">Link til Github repo</a>
            <br> <br>

            På den første page har jeg lavet en liste over appens hardcoded retter - og andet page indeholde detaljer
            omkring ingredienser.

        </p>

        <div style="width: 100%; display: flex;">

            <div style="text-align: center; width: 100%; padding-top: 60px;">
                <img src="images/recipe_home.png" alt="" style="height: 500px;">
                <img src="images/recipe_detail.png" alt="" style="height: 500px;">
            </div>

            <div>
                <pre>
                    <code>
                        <p>
                //1
                void main() {
                    runApp(const RecipeApp());
                }
                
                //2
                class RecipeApp extends StatelessWidget {
                    const RecipeApp({Key? key}) : super(key: key);
                    
                    @override
                    Widget build(BuildContext context) {
                        final ThemeData theme = ThemeData();
                        //3
                        return MaterialApp(
                            debugShowCheckedModeBanner: false,
                            title: 'Recipe Caluculator',
                            theme: theme.copyWith(
                                colorScheme: theme.colorScheme.copyWith(
                                    primary: Colors.blue,
                                    secondary: Colors.black,
                                ),
                            ),
                        home: const HomePage(title: 'Recipe Calculator'),
                        );
                    }
                }
        
                //4
                class HomePage extends StatefulWidget {
                final String title;
                const HomePage({Key? key, required this.title}) : super(key: key);
            
                @override
                State<HomePage> createState() => _HomePageState();
                }
            
                class _HomePageState extends State<HomePage> {
                @override
                Widget build(BuildContext context) {
                //5
                return Scaffold(
                    backgroundColor: Colors.blueGrey,
                    appBar: AppBar(
                        title: Text(widget.title),
                        centerTitle: true,
                        ),
                        //6
                        body: Padding(
                            padding: const EdgeInsets.all(16),
                            child: SafeArea(
                                //7
                                child: ListView.builder(
                                    itemCount: Recipe.samples.length,
                                    itemBuilder: (BuildContext context, int index) {
                                        //8
                                        return GestureDetector(
                                            child: recipeCard(Recipe.samples[index]),
                                            onTap: () {
                                                Navigator.push(
                                                    context,
                                                    MaterialPageRoute(
                                                        builder: (context) {
                                                            return RecipeDetail
                                                            (recipe: Recipe.samples[index]);
                                                        </p>
                                                    </code>
                                                </pre>
            </div>

        </div>

        <p class="blogcontext">

        <ol class="blogcontext">
            <li>Alle Flutter applikationer starter ligesom mange andre med en <b>main</b> metode, som kalder
                <b>runApp</b> metoden med
                en widget som parameter. Den fortæller Flutter i dette tilfælde at <b>RecipeApp</b> er vores top-level
                app
                eller root widget. <br><br>
            </li>
            <li>RecipeApp er den widget jeg bruger som indgangsvinklen til resten af appens komponenter. Så her kan jeg
                definere ting som appens titel og tema. (Denne widget er af type <b>Stateless</b>, som jeg vil redegøre
                for i
                et senere indlæg). <br> <br>
            </li>
            <li> <b>MaterialApp</b> er en klasse som fortæller os at appen bruger <b>material design</b>, som er et
                design system
                udviklet af Google. Det indebære nogle fælles principper, komponenter og styling, som er med til at
                hjælpe os udviklere med at bygge ensartet bruger oplevelser på tværs af platforme. <br>
                Med dens <b>home</b> property, der tager et widget som parameter, kan jeg sætte default routen når appen
                åbnes.
                <br> <br>
            </li>
            <li> <b>Homepage</b> er det widget som skal håndtere alt hvad vi kommer til at se på "startsiden". Det vil
                være de
                underliggende widget som definere udseendet, inde i <b>build</b> metoden.<br> <br>
            </li>
            <li>Et af de mest anvendte widgets til at implementere et basic visuel layout er <b>Scaffold</b>. Kigger man
                på
                dens properties vil man kunne genkende mange visuelle elementer som vi er en standard inden for apps.
                Såsom AppBar, BottomAppBar, FloatingActionButton og Drawer<br> <br>
            </li>
            <li><b>Padding</b> er et godt eksempel på at i Flutter er alt en widget. Så i kontrast til web development
                med HTML
                og CSS, hvor padding er en property du tildeler et UI element. Så er padding i Flutter sit eget widget,
                som du <i>"wrapper"</i> uden om et eller flere widgets.<br> <br>
            </li>
            <li>Et <b>Listview</b> widget kan ses lidt som et for loop, hvor vi specificere en længde og et "item" vi
                gerne vil
                bygge.<br> <br>
            </li>
            <li>Det item er et <b>recipeCard</b> widget som består af et <b>Image</b> og <b>Text</b> widget wrappet i en
                <b>Column</b> widget,
                wrappet i et <b>Card</b> widget. recipeCard er wrappet i en <b>GestureDetector</b> widget som vil
                navigere os ind på
                en ny page - <b>RecipeDetail</b> .<br> <br>
            </li>
        </ol>

        </p>

        <p class="blogcontext">
            Det sidste punkt er et godt eksempel på hvor indviklet det kan være at forklare Flutters widget struktur,
            også kaldt <b>widget tree</b>, når først man arbejder med mange elementer.
            Forneden har jeg to eksempler på hvordan den gennemgået kodes widget tree kan visualiseres.

        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/widget_tree_flutter_exten.png" alt="" style="height: 400px;">
            <img src="images/widget_tree_box.png" alt="" style="height: 400px;">
        </div>

        <hr>

        <h5 class="blogcontext">Kilder</h5>

        <ul class="blogcontext">
            <li>Flutter Apprentice - Sektion 1</li>
        </ul>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">1. Firebase projekt og tutorial review </h2>
        <div class="databaseLabel" style="margin-right: 5px;">
            <b>Database</b>
        </div>

        <h5 class="blogcontext">21-02-2022</h5>
        <p class="blogcontext"> Efter at jeg er blevet mere komfortable med nogle af de fundamentale koncepter indenfor
            Flutter. Ville jeg gerne i gang med at prøver at implementere backend logik ved hjælp af Firebase. <br>
            Mit mål var derfor i første omgang at kunne formidle til mit Database Guild, nogle af de egenskaber Firebase
            kan tilbyde og samtidig demonstrere det i en live applikation. <br><br>

            På forhånd havde jeg set nogle videoer på Youtube omkring Firebases koncept, som omhandler meget mere en
            bare opbevaring af data. Hele platformen er bygget op omkring individuelle services som du kan tilkoble til
            din applikation efter behov. <br><br>

            Nedenstående billede viser hvilket services de tilbyder - og de markerede er dem jeg har tænkt mig at
            eksperimentere med.
        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/Firebase_services.png" alt="" style="height: 300px;">
        </div>

        <p class="blogcontext"> For at få den bedste introduktion til Firebase og med Flutter, fandt jeg en separat
            sektion på deres hjemmeside, ved navn <b>FlutterFire</b> (opfindsomt), der lagde op til meget af det som jeg
            forventede at skulle bruge. <br><br>
            Jeg gik i gang med deres anbefalede introduktions-tutorial for nybegyndere <a
                href="https://firebase.google.com/codelabs/firebase-get-to-know-flutter#0">Codelab: Get to know Firebase
                for Flutter</a>, hvor jeg gerne skulle ende ud med en app, som brugte Authentication, Cloud Firestore og
            Cloud Messaging. <br><br>

            Man kan enten vælge at se en video som gennemgår stepsene eller kan man selv læse dem, jeg valgte en
            blanding. Første tre steps var ret lige til og gennemgik primært opsætningen af projekter i VS Code og
            Firebase - eftersom at jeg allerede havde prøvet det før lykkede denne del uden større problemer. <br><br>
            Step fire, hvor man skal til at configurer sine VS Code projekt med sin Firebase projekt, går det op for mig
            at der ikke var en præcis sammenhæng mellem videoerne og teksten til stepsene. Derudover blev der flere
            steder brugt forældet kode syntax, som resulterede i mange timer refaktorering og problemløsning på ting som
            ikke blev dækket i stepsene. <br><br>

            Tutorialen var en meget copy-paste gennemgang af nogle af Firebases features, forstået på den måde at ham
            som fortæller/koder løber til tider ret let over nogle komplicerede implementationer for at kunne nå det
            hele. Derfor ser jeg ikke denne tutorial som en "code along", men mere en
            "hold-på-hat-og-briller-gennemgang", for at demonstere hvor hurtigt man kan implementere Firebase i sit
            projeket. <br> <br>
            De har nogle mere dybdegående tutorials for de enkelte services, som vil være det næste jeg skal se på. <br>

            Til gengæld er det altid forløsning at få udviklet noget som virker - og jeg fik, på trods af mange
            udfordringer, lavet en applikation som kommunikere med mit Firebase Projekt.

        </p>

        <div style="text-align: center; width: 100%; ">
            <img src="images/databaseG1.png" alt="" style="height: 400px;">
        </div>

        <p class="blogcontext">
            Det er en ret simple applikation som fremviser et event, der til at starte med kun har nogle informationer
            om eventet. Men brugerne af appen skal også kunne interagere med eventet, så det første jeg gjorde var at
            tilføje en Email/Password sign-in provider i mit Firebase panel.

        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/Firebase_signin.png" alt="" style="height: 250px;">
        </div>

        <p class="blogcontext">
            Jeg vil i appen kunne administrere baseret på brugeren input om den indtastede mail tilhøre en eksisterende
            bruger og opdatere UI'et der til.
            Når brugeren så har oprettet sig og/eller logget ind, vil der blive fremvist to andre features. En
            tilmelding og en chat.

        </p>

        <div style="text-align: center; width: 100%; ">
            <img src="images/databaseG3.png" alt="" style="height: 400px;">
            <img src="images/databaseG2.png" alt="" style="height: 400px;">
        </div>

        <p class="blogcontext">
            Begge dele har jeg forbundet til en Firestore Database. Den består af to separeret collections, som er en
            samling af "dokumenter". Så hver gang en bruger interagere med tilmeldingen eller chatten, vil der enten
            blive tilføjet nye dokumenter til kollektionerne eller ændret på dokumenter i kollektionerne. Alt dette sker
            live når appen køres.
        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/Firebase_firestore.png" alt="" style="height: 250px;">
        </div>

        <p class="blogcontext">
            Når man starter en ny Firestore collection, vil der ikke være nogle begrænsninger for hvem der kan læse og
            skrive til databasen gennem appen - jeg forstiller mig at det er for testmæssige årsager. Det vil
            naturligvis være muligt at begrænse adgangen til din databasen gennem UI'et, så lidt ligesom jeg gemt noget
            fra personer som ikke er logget ind.
            Men for være helt sikker på at uautoriseret bruger ikke benytter databasen kan man opstille "rules" for sine
            kollektioner.

        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/Firebase_firestore_rules.png" alt="" style="height: 250px;">
        </div>

        <p class="blogcontext">På billedet ovenfor kan man se hvilket rules jeg har opstillet for guestbook (linje 4) og
            attendess (linje 12). <br> På linje 5 tillader jeg adgang til at læse fra databasen, hvis den modtaget read
            anmodning ikke er lige med null. Dette er måske ikke den bedste løsning, fordi jeg sikre mig egentligt ikke
            imod at anmodningen kommer fra en oprettet bruger i projektet. Så hvis man kunne komme udenom login/opret
            formularen, og på en måde få sendt hvilket som helst id med i anmodningen, ville fremvisningen af, i dette
            tilfælde chatten, kunne lade sig gøre. <br><br>

            Det gør jeg til gengæld fra linje 6 til 10, hvor jeg opstiller reglerne for anmodninger som skriver til
            databasen. Her sikre jeg at det brugerId som kommer med fra anmodning stemmer overens med en autoriseret
            bruger i projektet. <br><br>

            Et eksempel på hvis vi ikke var interesseret i at skjule indholdet fra en Firestore collection, kan ses på
            linje 13. Dette vil typisk være defaulten for en collection og gør det muligt for alle i appen at få
            fremvist, i dette tilfælde, hvor mange som deltager til eventet. <br><br>

        </p>

        <hr>

        <h5 class="blogcontext">Kilder</h5>

        <ul class="blogcontext">
            <li><a href="https://firebase.flutter.dev/docs/overview/ ">https://firebase.flutter.dev/docs/overview/ </a>
            </li>
            <li><a
                    href="https://www.youtube.com/watch?v=wUSkeTaBonA&t=15s&ab_channel=Firebase">https://www.youtube.com/watch?v=wUSkeTaBonA&t=15s&ab_channel=Firebase</a>
            </li>
        </ul>



    </div>
    <div class="blogpost">

        <h2 class="blogcontext">Stateless vs. Statefull</h2>
        <div class="frontendLabel" style="margin-right: 5px;">
            <b>Frontend</b>
        </div>

        <h5 class="blogcontext">24-02-2022</h5>
        <p class="blogcontext">
            I Flutter eksistere der to former for widgets, stateful widgets og stateless widgets. <b>State</b> er et
            term som jeg ofte støder på når jeg har læst om app udvikling og især <b>state-management</b> anses som en
            absolut must hvis du skal være en app udvikler. <br> Men hvad er state? <br><br>

            En apps state kan defineres som hvad end der eksistere i appens hukommelse, mens den køre. Dette kan være
            alt fra konfigurerings filer, datamodels, app assests og naturligvis alle widgets som udgør
            brugergrænsefladen. Nogle gange vil vi gerne kunne ændre staten af vores app i form af fremvisning af
            specifikke UI elementer eller ændring af et widgets variabler i run time - og andre gange er det vigtigt at
            de ikke kan ændre sig og forholder sig statiske under run time. <br><br>

            En <b>Stateless widget</b> gør præcis det sidst nævnte. Når denne form for widget bliver bygget, vil den,
            samt dens indhold, være uforanderlig og kan ikke ændre på appens state. De bruges typisk til at fremvise
            elementer og information - så nogle eksempler på hyppigt brugte stateless widgets vil være Text, Icon,
            Dialog, Card, SnackBar. De er nyttige til når brugergrænsefladen som du beskriver ikke er afhængige af andre
            parametre end dem du giver til at starte med og ikke skal ændre på appens state. <br><br>

            Hvis vi derimod skal kunne interagere med appens state under run time, skal man bruge <b>Statefull
                widget</b>. Denne form for widget er dynamisk og kan ændre sit udseende som et respons til udløst event
            af brugeren eller modtagelse af data. Textfield, Checkbox, RadioButton og Sliders er gode eksempler på
            statefull widgets, fordi de kan konstant ændre under et widgets livscyklus. <br>
            Et widgets state er opbevaret i et <b>state objekt</b>, som separere widgetens state fra dens udseende. For
            at kunne aktivere ændringen af et widgets state og derved opdatere dens udseende, kalder man på et state
            objektets <b>setState()</b> funktion. Den fortæller frameworket at "gentegne" widget'et fra ny og derved
            præsentere brugen for dens nye state og de tilsvarende ændringer. <br><br>

            For at demonstere hvordan disse to former for widgets fungere har jeg lavet en simple applikation som består
            af noget tekst, som er vores stateless widget og en checkbox som vores statefull widget.

        </p>

        <div style="width: 100%; display: flex;">

            <div style="text-align: center; width: 100%; padding-top: 60px;">
                <img src="images/stateGreen.png" alt="" style="height: 350px;">
                <img src="images/stateRed.png" alt="" style="height: 350px;">
            </div>

            <div>
                <pre>
                    <code>
                        <p>
                            //1
                            class ColorContainer extends StatefulWidget {
                                const ColorContainer({Key? key}) : super(key: key);
                              
                                @override
                                State<ColorContainer> createState() => _ColorContainerState();
                              }
                              
                              class _ColorContainerState extends State<ColorContainer> {
                                //2  
                                bool redColor = false;
                              
                                @override
                                Widget build(BuildContext context) {
                                  return Container(
                                    //3 
                                    color: redColor ? Colors.red : Colors.green,
                                    child: Center(
                                      child: Row(
                                        mainAxisAlignment: MainAxisAlignment.center,
                                        children: [
                                        //4
                                          const Text(
                                            'Red',
                                            style: TextStyle(fontSize: 30, fontWeight: FontWeight.bold),
                                          ),
                                          Transform.scale(
                                            scale: 1.4,
                                            //5
                                            child: Checkbox(
                                                value: redColor,
                                                onChanged: (bool? newValue) {
                                                  //6
                                                  setState(() {
                                                    redColor = newValue!;
                                                  });
                                                }),
                                          )
                                                        </p>
                                                    </code>
                                                </pre>
            </div>

        </div>

        <p class="blogcontext">

        <ol class="blogcontext">
            <li>Jeg har startet med at lave et widget <b>ColorContainer</b> som nedarver fra StatefulWidget klasse. På
                denne måde tilkendegiver jeg at i dette widget vil jeg kalde setState funktionen på et af mine
                widgets<br><br>
            </li>
            <li>Lidt ligesom en klasse i andre objekt orienteret sprog kan man definere variabler inde i sine
                klasser/widgets - dettet gør man oftes inden <b>build</b> metoden. I dette eksempel instantiere jeg min
                variable <b>redColor</b> med det samme. Men i nogle tilfælde vil man først have behov for at instantier
                dem senere. Her vil man bruge <b>late</b> keywordet og en <b>initState</b> metode. Begge vil blive
                dækket i et senere oplæg.<br><br>
            </li>
            <li>Som det næste angiver jeg farven som min Container skal have. Her bruger jeg variablen redColor i en
                <b>Ternary Conditional Operator</b>, som er en forsimplet måde at lave en en if else statement. Hvis
                redColor er true sættets containers color til rød, hvis false, grøn.<br><br>
            </li>
            <li>Text er som tidligere nævnt en stateless widget. Her har jeg angivet nogle specifikke værdier for
                widgetens variabler text, fontSize og fontWeight. Efter ColorContainer er bygget, vil disse variabler
                være uforanderlige.<br><br>
            </li>
            <li>Checkbox er en statefull widget og kræver at man angiver to variabler: value og onChanged.Inputtet for
                value skal være en bool datatype og vil typisk hedde isChecked, eftersom det er det vi man normalt vil
                registerer med en checkbox. onChanged tager imod en void funktion med en bool som parameter
                <b>(newValue)</b> og lytter på hvis den ændre sig<br><br>
            </li>
            <li>Når den så ændre sig (ved check eller uncheck) kalder jeg setState funktionen som sætter redColor til at
                være lige med newValue. Efter setState er blevet kaldt vil hele ColorContainer blive gentegnet - og hvor
                i step 3 redColor var false, vil den nu være true<br><br>
            </li>

        </ol>

        </p>

        <hr>

        <h5 class="blogcontext">Kilder</h5>

        <ul class="blogcontext">
            <li><a
                    href="https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app">https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app</a>
            </li>
            <li><a
                    href="https://www.geeksforgeeks.org/flutter-stateful-vs-stateless-widgets/?ref=lbp">https://www.geeksforgeeks.org/flutter-stateful-vs-stateless-widgets/?ref=lbp</a>
            </li>
            <li><a
                    href="https://docs.flutter.dev/development/ui/interactive">https://docs.flutter.dev/development/ui/interactive</a>
            </li>
        </ul>


    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Rento Update #1</h2>
        <div class="productLabel" style="margin-right: 5px;">
            <b>Produkt</b>
        </div>

        <h5 class="blogcontext">01-03-2022</h5>
        <p class="blogcontext">
            Jeg har nu været i gang med dette semester i lige knap en måned - og vi har netop haft det første med møde
            med vores product owner omkring status på Rento projektet.
            Under dette møde gennemgik vi til at starte med hvilket issues som der var færdiggjorte og hvilket som
            stadig var igangværende.
            Siden vi startede er følgende user stories færdigudviklet: <br>

        <ul>
            <li>Som en Udlejer (Renter) vil jeg kunne oprette et nyt produkt</li>
            <li>Som Udlejer vil jeg kunne styre kalenderen for et produkt jeg har til udleje</li>
            <li>Som Udlejer vil jeg kunne ændrer i et produkt jeg har til udleje</li>
            <li>Som Admin vil jeg håndtere kategorier</li>
        </ul>

        </p>

        <p class="blogcontext">

            De indebære naturligvis nogle underlæggende issues til både backend og frontend delen. Vi har måtte
            konkludere at frontend tager længere tid end forventet og overskrider mange af de tidsestimeringer som vi
            satte i starten af projektet. Dette betyder så også at mange af backend implementationer for andre issues er
            klaret og venter bare på frontend delen bliver lavet. <br><br>

            Med en klar opdeling af issues kunne vi også gøre vores PO opmærksom på at vi har nået at udvikle 32% af de
            samlede system. Ift. den estimerede tid på de issues vi har gennemført ligger den på 159 timer og den
            registrerede tid er 215 timer. Dette er selvfølgelig et stor forskel, men var dog forventet da vi har brugt
            meget tid på at lærer de nye teknologier og sprog. <br><br>

            Efterfølgende demonstrerede de dele af appen som var blevet færdigudviklet: Login/registerings flow, opret
            produkt flow og den administrative del. PO udtrykte stor tilfredshed med resultatet og havde ikke nogle
            indvendinger på det endelige design. Dette skyldes blandt andet også Little Giants konstante kommunikation
            med PO gennem Figma, hvor de har mulig for at komme med feedback på designet mens det laves.
        </p>


    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Hvad er en NoSQL database?</h2>
        <div class="databaseLabel" style="margin-right: 5px;">
            <b>Database</b>
        </div>

        <h5 class="blogcontext">04-03-2022</h5>
        <p class="blogcontext">
            Jeg har tidligere under mit uddannelsesforløb stiftet kendskab med MSSMS som er Micosofts Relationelle
            database. Her arbejdede jeg med data som havde relationer til hinanden og hvor jeg på tværs af tabels kunne
            fremvise informationer defineret af queries.
            Det er i høj grad en struktureret måde at arbejde med data på og jeg var derfor også en anelse skeptisk da
            jeg hørte omkring NoSQL databaser. <br><br>

            Fordi NoSQL er det som betegnes som shema-less. Det vil sige at hvor med en SQL database som inddeler sin
            data i tabels og de tabels kan forbindes ved hjælp af foreign keys - der opbevare en NoSQL databaser alt
            data samlet et sted. Der er ikke nogle restriktioner på database-niveauet hvorvidt den modtaget datatype er
            korrekt og hvornår den bliver indsat i database. Du behøves ikke engang at udfylde de samme felter som dine
            andre objekter i databasen, faktisk behøves det ikke engang at være det samme objekt. <br>
            Så hvorfor vil man bruge noget så ustruktureret? <br><br>

            NoSQL oprindelse går tilbage til 60'erne, men det var i de sene 2000 da omkostningerne for data opbevaring
            begyndte at falde dramatisk.


        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/dataCost.png" alt="" style="height: 350px;">
        </div>

        <p class="blogcontext">
            Billedet ovenfor illustrere prisforløbet på opbevaring af data per megabit de sidste 60 år. Med denne
            markante ændring af pris havde udviklere ikke længere behov for at lave komplekse og svære-at-vedligeholde
            data modeller for at undgå duplikering af data. <br><br>

            Fordi med en NoSQL vil man havde svært ved at undgå duplikering på grund af de manglende tabel relationer.
            Dette betød dog, ifølge MongoDB, at udviklerne kunne arbejde langt mere effektivt og fleksibelt fordi der
            ikke længere var en struktur som de skulle overholde, samtidig skulle de ikke længere være bekymret for
            ændringer af objekter og systemkrav. <br><br>

            De fire mest almindelig NoSQL databaser er:

        <ul>
            <li><b>Key-value</b> database er en af de mere simple typer. Her parres nøgler og værdier ved hjælp af et
                hashtable, på den måde kan man identificere en nøgles ukendte værdi.
            </li>
            <li><b>Document</b> database som opbevare data i samlinger som består af dokumenter lignede JSON objekter.
                Her består hvert dokument af fields og values, som beskriver en variable og dens datatype. (Cloud
                Firestore)

            </li>
            <li><b>Wide-column</b> database opbevare data i kolonner, brede kolonner og kolonnefamilier. Dette anses som
                en effektiv måde at lave forespørgsler på data på tværs af rækker i bestemte kolonner.

            </li>
            <li><b>Graph</b> database opbevare data i nodes og edges. Nodes indeholder typisk information omkring
                mennesker, steder og ting, mens edges indeholder information omkring relationerne mellem nodes
            </li>
        </ul>
        </p>

        <p class="blogcontext">
            I følge <a
                href="https://www.youtube.com/watch?v=v_hR4K4auoQ&list=PLl-K7zZEsYLluG5MCVEzXAQ7ACZBCuZgZ&index=1&ab_channel=Firebase">Get
                to know Cloud Firestore part 1</a>, kommer NoSQL til at harmonere godt med mit andet emne frontend
            programmering, hvor jeg begyndt at arbejde mere med validering af bruger input. <br> De fortæller at når man
            bruger NoSQL vil man skulle "kode defensivt" på client side. Fordi selvom du kan opstille security rules for
            hvilken data du indsætter hvor, så er der i virkeligheden ikke nogen garanti for på database niveauet
            hvilken data du modtager.
            Derfor er det op til brugergrænsefladen at navigere brugerens input over imod det ønskede resultat. <br><br>

            Noget som også adskiller NoSQL fra en almindelig SQL database er dens egenskab til nemt at distribuere sin
            data over flere maskiner.


        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/database_scaling.png" alt="" style="height: 350px;">
        </div>

        <p class="blogcontext">
            Lad os sige vi har en SQL database som opbevare noget data for vores Rento projekt - det kunne være brugere,
            produkter, beskeder osv. Forhåbentligt vil der komme et større antal af brugere eller produkter jo længere
            tid appen er live, og på et eller andet tidspunkt vil det være nødvendigt at skalere vores database for at
            få mere plads. <br> <br>
            Med en almindelig SQL database ville det typisk være nødvendigt at anskaffe en større og kraftigere maskine
            for at have sin database kørende - dette kaldes for <b>vertikal skalering</b>. <br>
            Derimod med en NoSQL database, som Fireastore, der skalere den <b>horisontalt</b>, forstået på den måde at
            når databasen har brug for mere plads vil den kunne distribuere sit data over flere servere. <br><br>


            Der findes naturligvis fordele og ulemper ved begge former for databaser - og specifikke scenarier hvor den
            ene egner sig bedre end den anden. Men inden for mobil applikation udvikle, hvor reads fra databasen typisk
            prioriteres højere end writes, vil det åbenlyse valg være en NoSQL database.

        </p>

        <hr>

        <h5 class="blogcontext">Kilder</h5>

        <ul class="blogcontext">
            <li><a href="https://www.mongodb.com/nosql-explained">https://www.mongodb.com/nosql-explained</a></li>
            <li><a href="https://azure.microsoft.com/da-dk/overview/nosql-database/
                        ">https://azure.microsoft.com/da-dk/overview/nosql-database/
                </a></li>
            <li><a
                    href="https://docs.microsoft.com/da-dk/azure/architecture/data-guide/big-data/non-relational-data">https://docs.microsoft.com/da-dk/azure/architecture/data-guide/big-data/non-relational-data</a>
            </li>
        </ul>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Opret Produkt Flow - part 1</h2>
        <div style="display: flex;">
            <div class="frontendLabel" style="margin-right: 5px;">
                <b>Frontend</b>
            </div>
            <div class="productLabel">
                <b>Produkt</b>
            </div>
        </div>

        <h5 class="blogcontext">09-03-2022</h5>
        <p class="blogcontext"> <b><i>Som en Udlejer (Renter) vil jeg kunne oprette et nyt produkt</i></b>  - er blandt de vigtigste userstories som findes i systemet og det er derfor også vigtigt at oprettelses flowet føles intuitiv og brugervenligt. Det kan blandt andet gøres ved at genbruge elementer og principper som vi, som brugere, er blevet vante til i forskellige oprettelse-scenarier. <br><br>

            For Rentos oprettelse af produkt var der nogle klare linjer imellem hvert element som skulle udgøre et produkt - og eftersom at det er en mobil applikation vi udvikler, vil der være en begrænset mængde plads på skærmen, som helst skal udnyttes bedst muligt. Dette kaldes også for <b>screen real estate</b>. <br><br>
            
            Heldigt for os er der ansat en dygtig UX (User Experience) designer hos Little Giants, som på forhånd har designet hvordan oprettelses flowet skulle foregå. Dette har været en fast del af processen når jeg har skulle implementere noget nyt frontend. <br><br>
            </p>

            <div style="text-align: center; width: 100%;">
                <img src="images/add_product_figma.png" alt="" style="height: 250px;">
            </div>

            <p class="blogcontext">
                Billedet foroven er taget indefra Figma som er det design værktøj som Little Giants designer sit UI i. Her er det lidt nemmere at se de elementer jeg nævnte tidligere som udgør et produkt.
                Det er: billeder, produktbeskrivelse, kategorier, afhentningssted og pris. <br><br> 
                
                Det som jeg skal være opmærksom på når jeg implementere et så omfattende issue bestående af flere dele, er blandt andet hvilket elementer eller i det her tilfælde widgets som der går igen. På den måde kan jeg sikre mig fra start at udvikle widgetet som kan genbruges. <br>
                Et godt eksempel på dette, ud fra designet, ville være header'en, altså den øverste del af af sidenerne og navigations baren i bunden. De er stort set ens på alle steps og giver derfor mening at lave et fælles widget for dette. <br> <br>
                I koden forneden kan man se hvordan jeg har lavet headeren - <b>CreateProductHeader</b>. 
                

            </p>

            <div style="width: 100%; display: flex;">

                
    
                <div class="codeContainer">
                    <pre>
                        <code>
                            <p style="color: #ece4dc;">
        <span style="color: #FF6C8A;">//1</span>
        class CreateProductHeader extends StatelessWidget {
            final String stepTitel;
            final Function? onTap;
            const CreateProductHeader({
            Key? key,
            required this.stepTitel,
            this.onTap,
            }) : super(key: key);
        
            @override
            Widget build(BuildContext context) {
            return Container(
                width: double.infinity,
                height: 140,
                child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                    <span style="color: #FF6C8A;">//2</span>
                    GestureDetector(
                        child: Icon(
                            Icons.arrow_back_ios,
                            size: 30,
                        ),
                        onTap: () {
                            if (onTap != null) {
                            onTap!();
                            }
                        }),
                    SizedBox(
                        height: 20,
                    ),
                    <span style="color: #FF6C8A;">//3</span>
                    Headline5(
                        translate(stepTitel),
                    ),
                    ],
                ),
                ),
            );
            }
        }
                                                            </p>
                                                        </code>
                                                    </pre>
                </div>

                    <ol class="blogcontext">
                        <li>Til at starte med definere jeg nogle parametre som CreateProductHeader skal have, når den bliver brugt. <br><b>stepTitel</b> er noget simpel tekst og <b>onTap</b> kan være hvilket som helst funktion vi parser med dete widget (Men navnet siger lidt hvad den skal bruges til). <br> Spørgsmålstegnet efter Function betyder at denne parameter er valgfri. <br><br></li>
                        <li>Selve opsætningen af headeren er ret simpel. Tilbageikonet bruger jeg et ikon fra Icons klassen som er supportet af material design som tilbyder flere hundrede forskellige ikoner. Men selve ikonet kan ikke noget for sig selv, jeg har derfor wrappet et <b>GestureDetector</b> widget. <br> Dette widget er ret interessant og vil blive dækket i et andet indlæg. Men kort fortalt har den en onTap parameter som lytter på et tap/tryk på skærmen for det widget som dette er wrappet omkring.
                        <br><br></li>
                        <li>Her kan jeg parse min egen onTap function som CreateProductHeader tager med.
                            Dette samme gør jeg for stepTitel. Som bliver vist med en Headline5 teksttype. Som er en af vores egne prædefineret teksttyper, der matcher designet fra Figma. Jeg kan igen derfor minimere mængden af kode alle steder jeg ville brugen den teksttype.</li>

                    </ol>
                
            </div>

            <div style="width: 70%; margin-left: auto; margin-right: auto;" class="codeContainer">

                <pre>
                    <code>
                        <p style="color: #ece4dc; font-size: 17px;">
                            
    <span style="color: #d4ba51;">CreateProductHeader</span>(
        stepTitel: <span style="color: #8396bd;">translate</span>(<span style="color: #61b36d;">'create_product.add_product_description_title'</span>),
        onTap: <span style="color: #ca531f;">widget.back</span>,
        ),
                            </p>
                        </code>
                    </pre>
                </div>
            
                <p class="blogcontext">
                    Når jeg så kalder på CreaterProductHeader i et af stepsene vil jeg kunne udfylde parametrene derfra, så den specifikt passer til det step jeg er på. <b>Translate</b> er en package vi bruger til at lave oversættelser på tekster i appen som er statiske. I første omgang vil der kun være danske oversættelser, men på sigt vil det gøre det lettere at tilføje nye oversættelser. <br><br>
                    For onTap parser jeg <b>widget.back</b> som er en funktion der er en parameter for det widget som jeg har kaldt CreateProductHeader i.
                    Det vil sige at jeg parser den tidligere nævnte GestureDetectors onTap funktion videre til at andet widget - eller faktisk page.  <br><br>

                    Fordi netop den her funktion skal gøre det samme for alle stepsene i oprettelses flowet, som er at den skal gå et step tilbage. Så jeg har i stedet for at definere den samme funktion i hvert step, håndtere det i <b>CreateProductPage</b>.
                </p>

                <p class="blogcontext">Ved første øjekast minder en page og et widget meget om hinanden - man ville sikkert godt kunne argumentere for at en page er et widget. Men det som gør sig gældende for en page er dens Scaffold widget - som kan ses som kroppen for de widget vi definere i den. Det betyder så også at alle widgets som jeg bruger indenfor Scaffold, låner "kroppen" af sit deres parent widget.
                </p>

                <div style="width: 100%; display: flex;">

                
    
                <div class="codeContainer">
                    <pre>
                        <code>
                            <p style="color: #ece4dc;">
    class CreateProductPage extends ConsumerStatefulWidget {
        CreateProductPage({Key? key}) : super(key: key);
        
        @override
        ConsumerState<CreateProductPage> createState() => _CreateProductPageState();
        }
        
        class _CreateProductPageState extends ConsumerState<CreateProductPage> {
        <span style="color: #FF6C8A;">//1</span>
        late final PageController _pageController = PageController();
        
        final _productTitleController = TextEditingController();
        final _productDescriptionController = TextEditingController();
        final _imagesController = ValueNotifier<List<String>>([]);
        final _categoriesController = ValueNotifier<List<String>>([]);
        final _pickupZipcodeController = ValueNotifier<DawaZipcode?>(null);
        final _pickupAddressController = ValueNotifier<DawaAddress?>(null);
        final _pricePerDay = TextEditingController(text: '20');
        
        @override
        Widget build(BuildContext context) {
            return Scaffold(
            body: SafeArea(
                child: GestureDetector(
                onTap: () {
                    FocusScopeNode currentFocus = FocusScope.of(context);
        
                    if (!currentFocus.hasPrimaryFocus) {
                    currentFocus.unfocus();
                    }
                },
                child: PrimaryBackground(
                    <span style="color: #FF6C8A;">//2</span>
                    child: PageView(
                    physics: NeverScrollableScrollPhysics(),
                    controller: _pageController,
                    children: [
                        AddImagesStep(
                        imagesController: _imagesController,
                        next: _nextStep,
                        jumpToStep: _jumpToStep,
                        ),
                        ChooseImagesStep(
                        imagesController: _imagesController,
                        next: _nextStep,
                        back: _previousStep,
                        ),
                        ChosenImagesStep(
                        imagesController: _imagesController,
                        next: _nextStep,
                        back: _previousStep,
                        jumpToStartStep: _jumpToStep,
                        ),
                        <span style="color: #FF6C8A;">//3</span>
                        AddProductDescriptions(
                            productTitleController: _productTitleController,
                            productDescriptionController: _productDescriptionController,
                            next: _nextStep,
                            back: _previousStep),
                            .......
                    ],
                    ),
                ),
                ),
            ),
            );
        }
                                                            </p>
                                                        </code>
                                                    </pre>
                                                    
                </div>


                    <ol class="blogcontext">
                        <li>Først og fremmest har jeg på denne page defineret nogle variabler som skal bruges når produktet skal oprettes. Naturligvis har de ikke nogle værdier endnu, men de får de jo længere bruger kommer i oprettelses flowet. <br><br> <ul>
                            <li><b>Controllere</b> er ikke det samme i Flutter som de controllere jeg har lært om i C#, henholdsvis MVVM og MVC. Derimod skal de ses som en måde at opbevare en værdi eller state for et widget. Så på den måde når bruge navigere rundt på de forskellige steps, vil de angivet værdier ikke gå tabt. Omfanget for controller og <b>valuenotifier</b> er selvfølgelig lidt mere omfattende end bare det - så det vil blive dækket i et andet indlæg.</li>
                            <li><b>PageControlleren</b> er ret essentielt for at vi kan manipulere med hvilken siden som er synligt i vores PageView.
                            </li>
                        </ul> <br><br>
                        </li>
                        <li>Et <b>PageView</b> er et widget som består af en "scrollable" liste af wigets/pages, der er defineres som dens children. Men i lige dette tilfælde skal brugeren ikke have mulighed for at scrolle, eftersom der er knapper til at navigere brugeren. Derfor har jeg sat dens parameter <b>physics</b> til <b>NeverScrollableScollPhysics()</b>, som neutralisere denne funktion. <br><br>
                            <ul>
                                <li>Dens children består af alle steps for oprettelses flowet i designets kronologisk rækkefølge (Jeg har undladt nogle steps i dette eksempel). Som man kan se tager de alle imod nogle forskellige parametre i form af controllere og funktioner - og det er nogle af disse funktioner som jeg nævnte tidligere der gældende for dem allesamme.</li>
                            </ul>
                        <br><br></li>
                        <li><b>AddProductDescriptions</b> back funktion (widget.back fra tidligere) kalder en lokal funktion ved navn <b>_previousStep</b>.</li>

                    </ol>
                
            </div>
            <div style="width: 70%; margin-left: auto; margin-right: auto;" class="codeContainer">

                <pre>
                    <code>
                        <p style="color: #ece4dc; font-size: 17px;">
                            
    <span style="color: #d4ba51;">Future</span><span style="color: #b065a4;"> void</span> <span style="color: #8396bd;">_previousStep()</span><span style="color: #b065a4;"> async</span>{
    <span style="color: #b065a4;">await</span> <span style="color: #ca531f;">_pageController</span>.<span style="color: #8396bd;">previousPage</span>(
        duration: <span style="color: #d4ba51;">Duration</span>(milliseconds: <span style="color: #ca531f;">200</span>), curve: <span style="color: #d4ba51;">Curves</span>.<span style="color: #ca531f;">linearToEaseOut</span>);
        <span style="color: #d4ba51;">FocusScope</span>.<span style="color: #8396bd;">of</span>(<span style="color: #ca531f;">context</span>).<span style="color: #8396bd;">unfocus</span>();
        }
                            </p>
                        </code>
                    </pre>
                </div>

                <p class="blogcontext">
                    Det som denne funktion udføre er at kalde på _pageControllerens <b>previousPage</b> funktion, som vil navigere brugeren tilbage til den tidligere child i et PageView widget. Jeg har tilføjet en varighed på animationen for at gøre overgangen mere brugervenlig. <br><br>

                    Funktionen returnere en <b>Future</b> void, det vil naturligvis sige ingenting. Men Future repræsentere et resultat fra en asynkron operation, som kan være uncompleted eller completed. I uncompleted state vil den vente til operationen færdiggøres eller smide en error. Normalt bruges asynkron kode når man gerne vil udføre nogle ting mens andre operationer færdiggøres, typisk vil det blive brugt i scenarier hvor man læser eller skriver til en database eller fil. <br>
                    Det er ikke tilfældet her, men jeg vil stadig gerne sikre mig at det tidligere step bliver loaded uden problemer og med værdierne fra controllerne. <br><br>

                    I næste part vil jeg vise hvordan jeg kommnikere med vores backend og rent faktisk får oprettet produktet i databasen.
                </p>
                <hr>

                <h5 class="blogcontext">Kilder</h5>

                <ul class="blogcontext">
                    <li><a href="https://api.flutter.dev/flutter/widgets/PageController-class.html">https://api.flutter.dev/flutter/widgets/PageController-class.html</a></li>
                    <li><a href="https://api.flutter.dev/flutter/widgets/PageView-class.html
                        ">https://api.flutter.dev/flutter/widgets/PageView-class.html
                    </a></li>
                    <li><a
                            href="https://dart.dev/codelabs/async-await
                            ">https://dart.dev/codelabs/async-await
                        </a>
                    </li>
                </ul>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Strukturering af data</h2>
        <div class="databaseLabel" style="margin-right: 5px;">
            <b>Database</b>
        </div>

        <h5 class="blogcontext">15-03-2022</h5>
        <p class="blogcontext">
            Jeg har valgt at bruge tid på at undersøge hvilket muligheder der findes med indenfor strukturering af data med Firestore. Formålet var i første omgang naturligvis at finde ud af hvilket typer der er - derefter fordelene, ulemper/begrænsninger og hvilket mulige usecases man ville bruge den ene frem for den anden. <br> <br>

            Jeg har kunne finde frem til tre helt overordnede strukturer indenfor Firestore. Dog findes der variationer af disse typer som fungere bedre i specifikke scenarier. 
            Som eksempel lader vi som om jeg har skal implementere en et chatforum, hvor der selvfølgelig er brugere og forskellige chatrum med et overordnet emne. <br><br>

            <b>Indlejret data i dokumenter:</b> er en af de mere simple former for datastruktur. Her vil vi have en collection for hver bruger i vores app som indeholde information om brugeren og et array af chatrum som brugeren deltager i. <br>
            Dette er en nem måde at opstille sin data på og kan streamlines for alle brugerne. Det har dog sine begrænsninger når det kommer til skalerbarheden - så der er stor sandsynlighed for at hastigheden vil blive minimeret i takt med at antallet af brugere stiger. <br>
            Denne data struktur vil fungere fint til fremvisning af en brugerprofil og deres aktive chatrum, da vi allerede har dataen direkte tilknyttet til brugeren og der skal derfor ikke køre yderlige queries.

        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/data_struc_1.png" alt="" style="height: 250px;">
        </div>

        <p class="blogcontext">
            <b>Subcollections: </b> vil man strukturere sin data med collections inde i dokumenter. I dette eksempel vil vores struktur være mere fleksibelt hvis mængden af bruger forbundet til chatrum stiger eller hvis vi vælger at tilføje flere chat rums. Så vil størrelsen på parent dokumentet altid forblive den samme størrelse. Dette har også sine fordele ift. quering af data. <br><br>
            Lad os sige vi gerne ville have antallet af bruger i software chat. Med data strukturen før ville vi skulle checke hver enkel bruger om software chat fandtes i deres array af rooms - med subcollections har vi på forhånd en liste af bruger som er tilknyttet til de enkelte chatrum. <br>
            Ulempen kommer i at det ikke er nemt at slette i subcollection når der eksistere data/dokumenter i den. Det vil sige at før vi sletter software chat skal subcollectionen af brugere før slettets.

        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/data_struc_2.png" alt="" style="height: 400px;">
        </div>

        <p class="blogcontext">
            <b>Root-level collections:</b>  opretter man separate collections for data som tydeligt adskiller sig fra hinanden. Root-level vil sige at de ligger på det yderste lag af ens firestore database. Denne form for data struktur egner sig især godt til når man gerne vil køre avanceret queries indenfor en collection og ifølge Google Cloud også til many-to-many relationships.
            Hvis vi tager udgangspunkt i samme problemstilling fra før hvor vi gerne vil have antallet af bruger i chatrum - er dette ikke længere mulig med denne data struktur. 


        </p>
        
        <div style="text-align: center; width: 100%;">
            <img src="images/data_struc_3.png" alt="" style="height: 450px;">
        </div>
        
        <p class="blogcontext">
            Når man snakker om hvilken datastruktur der egner sig bedst til sin applikation kan jeg konkludere at det afhænger meget af hvordan man forventer at brugeren skal interager med dataen og hvilket informationer de skal præsenteres for. Derfor vil jeg mene at det en vigtig del at for afklaret nogle af disse spørgsmål tidligt i opstartet/kravs indsamlings fasen for at undgå unødig arbejde går spildt. <br><br>
            Dette er naturligvis ikke de eneste måder at gøre det på og som sagt findes der variationer af de gennemgået strukturere. Men i sidste ende (i hvert fald når man arbejder med Firestore), er det vigtigt at strukturer sin data således at man undgår at læse unødig data, eftersom der også ligger et finansielt aspekt i de, som jeg vil dække i næste database indlæg.  
        </p>


        

        <h5 class="blogcontext">Kilder</h5>

        <ul class="blogcontext">
            <li><a href="https://www.youtube.com/watch?v=o7d5Zeic63s&list=PLl-K7zZEsYLluG5MCVEzXAQ7ACZBCuZgZ&index=5&ab_channel=Firebase">Maps, Arrays and Subcollections, Oh My! | Get to know Cloud Firestore #4</a></li>
            <li><a href="https://www.youtube.com/watch?v=haMOUb3KVSo&list=PLl-K7zZEsYLluG5MCVEzXAQ7ACZBCuZgZ&index=6&ab_channel=Firebase">How to Structure Your Data | Get to know Cloud Firestore #5</a></li>
            <li><a
                    href="https://cloud.google.com/firestore/docs/concepts/structure-data">https://cloud.google.com/firestore/docs/concepts/structure-data</a>
            </li>
        </ul>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Genbrug dine widgets</h2>
        <div class="frontendLabel" style="margin-right: 5px;">
            <b>Frontend</b>
        </div>

        <h5 class="blogcontext">21-03-2022</h5>
        <p class="blogcontext">
            Jeg er på nuværende tidspunkt i gang med at implementere fremvisning brugerens udlejningsaftaler, set som en lejer. Det er en meget essentiel del af appen og skal derfor føles overskueligt og reagere brugervenligt - eftersom at du vil som lejer (alt efter på mængde af udlejninger) bruge meget tid her på at administrere nye anmodninger, kommende aftaler og afsluttede aftaler(review). <br><br>

            Derfor syntes jeg det kunne være interessant at dokumentere dele af min arbejdsproces og fremgangsmåde. Den overordnede fremvisning af alle brugerens aftaler har jeg implementeret for nogle uger siden - og ser således ud.
        </p>

        <div style="text-align: center; width: 100%; ">
            <img src="images/rental_lejer.png" alt="" style="height: 400px;">
            <img src="images/rental_udlejer.png" alt="" style="height: 400px;">
        </div>

        <p class="blogcontext">
            Lige nu kan brugeren horisontalt scolle igennem sine aftaler eller tilgå en historik af tidligere aftaler. Men der ligger mere information og data omkring en enkel aftale end hvad vi lige får fremvist her. Så brugeren skal også kunne tilgå denne information, som gøres gennem en onTap gesture på hvert card. <br> <br>

            Billedet forneden er taget fra designet og illustrere hvordan data'en skal fremvises alt afhængig hvilken status aftalen har. Til venstre er aftalen(anmodningen) ny og afventer svar fra brugen. I midten er aftalen accepteret og brugerne vil nu kunne interagere med hinanden. Og til højre er aftalen(lejen) afsluttet og afventer et review af lejeren. <br> <br>

            Der går naturligvis en del information igen på siderne, men der er især et element som skiller sig fra de andre - og det er fremvisningen af produktbilledet, lokationen og udlejningsperioden.
        </p>
        
        <div style="text-align: center; width: 100%;">
            <img src="images/rental_info.png" alt="" style="height: 450px;">
        </div>
        
        <p class="blogcontext">
            Baseret på hvilken status aftalen har vil dette element har forskellige tilstande. Det var her jeg fik ideen til dette indlæg - fordi dette er et fint eksempel på hvordan mere komplicerede widgets kan blive genbrugt i forskellig scenarier. 
            Så i stedet for at lave, til dels, det samme widget flere gange, vil jeg lave et som nemt kan genbruges på alle siderne og måske også andre steder. <br><br>

            Efter at have arbejdet med Flutter i et stykke tid, er jeg begyndt at "visualisere" designets elementer lidt på samme måde som jeg viste til sidst i <b>Alt er et Widget</b> indlægget. Et widget-tree i klodser. <br><br>

            Så ud fra designet, hvor en aftale afventer svar, får jeg dette widget-tree.

        </p>
        
        <div style="text-align: center; width: 100%;">
            <img src="images/widget_tree_rental_info.png" alt="" style="height: 450px;">
        </div>

        <p class="blogcontext">
            Jeg laver naturligvis ikke sådan en analyse for hvert element. Men det hjælpe mig med at udføre implementeringen ved at visualisere det på denne måde. <br><br>
            Et af de helt fundamentale principper indenfor Flutter (og mange andre kodesprog), er så vidt muligt at genbruge kode. Så når jeg skal implementere et widget som dette, vil jeg gerne lave det så generisk, at det kan bruge i andre sammenhæng. 
            Kodeudklippet forneden viser hvordan jeg har implementeret den første "version" - RentalStatus.paid

        </p>

        <div style="width: 100%; display: flex;">

                
    
            <div class="codeContainer">
                <pre>
                    <code>
                        <p style="color: #ece4dc;">
    class RentalInfomationCard extends StatefulWidget {
    <span style="color: #FF6C8A;">//1</span>
    final RentalModel rental;
    final bool renterMode;
    const RentalInfomationCard(
    {Key? key, required this.rental, required this.renterMode})
    : super(key: key);

    @override
    State<RentalInfomationCard> createState() => _RentalInfomationCardState();
    }

    class _RentalInfomationCardState extends State<RentalInfomationCard> {
    @override
    Widget build(BuildContext context) {
    <span style="color: #FF6C8A;">//2</span>
    if (widget.rental.status.name == RentalStatus.Paid.name)
        return WhiteCard(
            child: Column(
                children: [
                Container(
                    clipBehavior: Clip.antiAlias,
                    height: 150,
                    decoration:
                        BoxDecoration(borderRadius: BorderRadius.circular(10)),
                    child: Row(
                        children: [
                            Expanded(
                            <span style="color: #FF6C8A;">//3</span>
                                child: Image.network(
                                widget.rental.product.images.first.image.url,
                                fit: BoxFit.cover,
                                ),
                            ),
                            Expanded(
                            child: IgnorePointer(
                            <span style="color: #FF6C8A;">//4</span>
                            child: FlutterMap(
                                options: MapOptions(
                                    center: widget.renterMode
                                    ? LatLng(
                                        widget.rental.product.approximateLocation
                                        .latitude,
                                        widget.rental.product.approximateLocation
                                        .longitude)
                                        : LatLng(
                                            widget.rental.product.pickupLocation!
                                            .latitude,
                                            widget.rental.product.pickupLocation!
                                            .longitude),
                                            zoom: 13),
                                            <span style="color: #FF6C8A;">//5</span>
                                            layers: [
                                            TileLayerOptions(
                                            urlTemplate:
                                            "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                                            subdomains: ['a', 'b', 'c'],
                                            attributionBuilder: (_) {
                                                return Text("© OpenStreetMap contributors");
                                            },
                                            ),
                                            if (!widget.renterMode)
                                            MarkerLayerOptions(markers: [
                                                Marker(
                                                width: 25,
                                                height: 25,
                                                point: LatLng(
                                                    widget.rental.product.pickupLocation!
                                                    .latitude,
                                                    widget.rental.product.pickupLocation!
                                                        .longitude),
                                                        builder: (marker) => Container(
                                                            child: SvgPicture.asset(
                                                                'assets/svgs/map_pin.svg'),
                                                        ),
                                                ),
                                                ]),
                                            if (widget.renterMode)
                                                CircleLayerOptions(circles: [
                                                    CircleMarker(
                                                        useRadiusInMeter: true,
                                                        borderColor: AppTheme.of(context).secondary,
                                                        color: AppTheme.of(context)
                                                        .secondary
                                                        .withOpacity(0.3),
                                                        point: LatLng(
                                                            widget.rental.product.approximateLocation
                                                            .latitude,
                                                            widget.rental.product.approximateLocation
                                                            .longitude),
                                                            radius: 500.0),
                                                    ]),
                                                ],
                                        ),
                                    ),
                                ),
                            ],
                        ),
                    ),
                    <span style="color: #FF6C8A;">//6</span>
                    DateDisplay(
                        price: widget.rental.product.pricePerDay.amount,
                        currency: widget.rental.product.pricePerDay.currency,
                        startDate: widget.rental.period.start,
                        endDate: widget.rental.period.end,
                        hideTotalPeriod: false,
                  )
                ],
              ),
            );
                                                        </p>
                                                    </code>
                                                </pre>
            </div>

                <ol class="blogcontext">
                    <li>RentalInformationCard som er navnet widget'en tager imod to parametre, en RentalModel og en boolean. 
                        <ul>
                            <li>Min RentalModels variabler skal blandt andet bruges til at udfylde felter, som parametre til andre widgets og afgøre hvilken version af RentalInformationCard som skal bygges.</li>
                            <li>Booleanen renterMode er en parameter som jeg bruger til afgøre om bruger har tilgået en aftale som udlejer eller lejer</li>
                        </ul>
                        <br><br>
                    </li>

                    <li>Der findes flere måder at gøre det på. Men jeg har valgt at tjekke om min tidligere nævnte RentalModel's status stemmer overens med en af mine prædefineret RentalStatus - som er en enum. For derefter at returnere et WhiteCard widget og det her vi begynder at kunne se starten på vores widget-tree. <br><br>
                    </li>

                    <li>Image er et widget som har flere forskellige constructorere og i dette tilfælde vil jeg gerne anvende network. Når man har oprettet et produkt vil dens tilknyttet billeder blive uploaded og hostet fra en af Little Giants servere. Et produkt har en liste af ProductImageModel, der har en StorageResourceModel, som opbevare en URL for hvert enkelt billede. Dette kan bruges som   Image.network's source. <br><br>
                    </li>

                    <li>FlutterMap er et tredjeparts library jeg bruger til at fremvis en et interaktivt kort. Jeg har dog valgt at wrappe det med en IgnorePointer, for ikke at gøre det interaktivt. Baseret på om brugeren skal have fremvist widgetet som lejer eller udlejer, eller om aftalen er accepteret, bruger jeg rentermode i et ternary. På den måde kan jeg enten vise en den præcise lokation eller en cirka lokation.
                    Det er et krav fra PO at brugerne ikke vil kunne se den nøjagtige lokation for produktet før aftalen er accepteret - af sikkerhedsmæsissige grunde.<br><br>
                    </li>

                    <li>FlutterMap har en parameter som hedder layers, som er en liste af LayerOption widgets. Med layers kan jeg tilføje ekstra UI elementer indenfor mit kort. Igen, afhængig af renterMode, fremviser jeg enten en pin/nål eller en transparant cirkel baseret på cirka lokationen.<br><br>
                    </li>

                    <li>DateDisplay er et andet widget jeg har defineret fra opret produkt flowet, og skal blot fremvis udlejnings periode, samt antal dage og pris.<br><br>
                    </li>

                </ol>
            
        </div>

    </div>

    <div class="blogpost">

        <h2 class="blogcontext">Database omkostninger</h2>
        <div class="databaseLabel" style="margin-right: 5px;">
            <b>Database</b>
        </div>

        <h5 class="blogcontext">25-03-2022</h5>
        <p class="blogcontext">
            En database har tre overordnet formål, opbevaring af data, manipulering af data og hentning af data. Som en del af min database research vil jeg også gerne undersøge hvilket omkostninger som er forbundet med brugen af en database, mere specifik Firestore Databasen. <br><br>

            <b>Hvad betaler du for?</b> <br>
            En ting jeg vil give Google kredit for, er hvor transparente de er i ift. hvilket omkostninger som følger med deres services og helt specifik hvad du kommer til at betale for. Sammenlignet med en Realtime database hvor omkostningerne mere eller mindre stiger proportionalt med mængden af data du uploader og downloader. Så vil omkostningerne for en Cloud database afhænge af mængden af operationer du eller brugerne udføre - og med operationer mener jeg read, writes og deletes. <br><br>

            Hver gang en bruger tilføjer eller ændre på et dokument i vores Firestore database, vil vi betale. Det samme gælder hvis brugeren henter data, f.eks. søger efter noget eller vælger at slette et dokument. Du har dog et specifikt antal af operation som dine bruger kan udføre om dagen før du skal betale.


        </p>

        <div style="text-align: center; width: 100%;">
            <img src="images/firebase_pricing.png" alt="" style="height: 250px;">
        </div>

        <p class="blogcontext">
            Antallet af operationer virker umildbart ud til at være højt og prisen er også overkommeligt, men det afhænger meget af hvilken applikation som det skal bruges til (eksempler kommer i næste hovedsektion). <br><br>

            En anden ting du også betaler for er Cloud funktioner. Det kan måske være beregninger som udgør et af dine objekters felter. 
            For eksempel hvis jeg laver en app hvor brugere kan rate en bog og jeg gerne vil fremvise en gennemsnitlig vurdering af den bog. Så er jeg nød til at have en cloud funktion som læser alle score tilknyttet til bogen og derved beregne gennemsnittet. <br><br>

            Det er en måde at gøre det. Men her skal man opmærksom på at når du læser en score tæller det som et individuelt read. Det vil sige at hvis  vi 1000 brugere, hvor 100 af dem har anmeldt en bog, bruges der 100 reads på at udfylde den bogs rating. Det vil man naturligvis skulle gøre for hver enkelt bog, hvilket hurtigt kan løbe op i mange reads. <br>
            Samtidig hvis der bliver tilføjet en ny score skal cloud funktionen køre igen, så nu 101 reads.
            Der er findes selvfølgelig nogle alternativer til hvordan man kan gøre dette og også hvordan man kan komme udenom firestores gratis begrænsning. Blandt andet ved at bruge lidt mere avanceret matematik end bare dividere antallet med summen eller ved ikke at opdatere ratingen hver gang der bliver tilføjet en ny score. Det kunne også beregnes direkte i frontenden - men dette vil højst sandsynligt ikke være billigere. <br><br>

            Derudover betaler man også en sum for mængden af data du opbevare og faktisk også mængden af bredbånd du bruger. Dette anses dog ifølge Cloud Firestore Pricing video, ikke som en omkostninger der har en stor indflydelse set i et større perspektiv. <br><br>

            <b>Så hvilket apps passer Firestore bedst til?</b><br>
            Nu ved vi helt præcist hvad det er vi betaler for, hvilket gør det nemmere for os at vurdere om Firestore er det rigtige database valg for os. Fordi i sidste ende afhænger det meget om hvilket app den skal bruges til og hvordan brugernes adfærd vil være. <br><br>

            Et godt eksempel på hvor jeg ikke ville benytte Firestore, er i applikationer som ofte skal opdatere. <br>
            Lad os sige jeg har en app hvor brugerne kan følge med i kursen på diverse kryptovalutaer. Selvom priserne ligger nogenlunde stabilt opdateres de normalt ca. hvert 15 sekund på den slags sider. Hvis så en af mine bruger har appen kørende i tre minutter og følger en kurs, skal den opdateres 12 gange = 12 reads. Lad os så sige at han har 10 kurser kørende og det samme har 500 andre bruger. Så har jeg pludselig 60.000 reads på tre minutter. Så rækker mine gratis operationer ikke så langt lige pludselig. <br><br>

            Det vil sige at der hvor Firestore stråler skarpes, set fra et økonomisk perspektiv, er i cases som ikke indebære hyppige opdateringer. Det kunne f.eks. være en app som bruges til at dele madopskrifter. I sådanne en app vil der gå lang tid imellem writes og reads vil være centreret omkring få opskrifter og ikke hele databasen indhold på en gang. <br>
            Men lad os nu sige at i den her madopskrifts app, skal brugerne kunne chatte med hinanden. Så afhænger det pludselig i hvilken skala brugerne kan chatte med hinanden i - om det bliver en dyr eller "billig" app at have på Firestore. <br><br>

            I et en-til-en chatrum, hvor brugerne ca. sender en besked hvert 10. sekund i 5 minutter vil generer 60 writes og 120 reads. Dette virker ret overkommeligt, også selvom vi skalere antallet op til, lad os sige 50 chatrum = 3000 writes og 6000 reads. <br>
            Dog er det blevet ret normalt at du kan have gruppe chat. Så hvis vi nu tager de bruger fra vores 50 chatrum (100 brugere) og smider dem ind gruppechat, så vil de alle naturligvis skulle opdateres når der bliver sendt en besked. Vi vil stadig stå med 3000 writes - men i stedet for 6000 reads, har vi 300.000. <br><br>

            Pointen er at man skal gøre sig nogle ret klare overvejelser for hvordan du forventer at din app skal bruges og hvilket krav den indebære. På den måde kan man undgå at få sig nogle grimme økonomiske overraskelser og i værste tilfælde indse at du har brugt unødvendig tid på at opstille en database i Firestore - der så alligevel ikke kan bruges. 

        </p>

        <h5 class="blogcontext">Kilder</h5>

        <ul class="blogcontext">
            <li><a href="https://www.youtube.com/watch?v=6NegFl9p_sE&list=PLl-K7zZEsYLluG5MCVEzXAQ7ACZBCuZgZ&index=5&ab_channel=Firebase">Cloud Firestore Pricing | Get to know Cloud Firestore #3</a></li>
            <li><a href="https://cloud.google.com/firestore/pricing">https://cloud.google.com/firestore/pricing</a></li>
            <li><a
                    href="https://aloa.co/blog/as-a-startup-should-use-firestore-for-my-app">https://aloa.co/blog/as-a-startup-should-use-firestore-for-my-app</a>
            </li>
        </ul>

    </div>

</body>

</html>